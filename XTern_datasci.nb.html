---
title: "Scooter Analysis"
output:
  html_document:
    df_print: paged
---
```{r}
Scooters <- read.csv("D:/Docs/Downloads/2019XTern_scooters.csv", header = TRUE)
summary(Scooters)
str(Scooters)
```

To identify popular scooter locations, I graphed the distribution of x and y 
coordinate separately and plotted the then in 2D:
```{r}
label <- c("-0.3", "-0.2", "-0.1", "0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", 
           "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4")
# limits on the x axis are based on the minimum and maximum values obtained from
#  the summary of the data
hist(Scooters$xcoordinate, xlab = "X Coordinate", xlim = c(-0.3020, 1.3710), 
     axes = FALSE, main = "Histogram of Scooter X Coordinates")
axis(1, at = seq(-0.3, 1.4, 0.1), labels = label)
axis(2, at = seq(0, 5000, 1000))

hist(Scooters$ycoordinate, xlab = "Y Coordinate", xlim = c(-0.29030, 1.35720), 
     axes = FALSE, main = "Histogram of Scooter Y Coordinates")
axis(1, at = seq(-0.3, 1.4, 0.1), labels = label)
axis(2, at = seq(0, 5000, 1000))

plot(x = Scooters$xcoordinate, y = Scooters$ycoordinate, type = "p", axes = FALSE, 
     xlab = "X Coordinate", ylab = "Y Coordinate", main = "Scooter Locations")
axis(1, at = seq(-0.3, 1.4, 0.1), labels = label)
axis(2, at = seq(-0.3, 1.4, 0.1), labels = label)
```

From these graphs, I can observe that the scooters cluster around specific locations.
Looking at the histograms, some x and y coordinates are particularly popular, 
with the y coordinates more evenly distributed than the x's. Graphing in 2D confirms 
the existence of popular pairs of x and y coordinates. In the graph, coordinates 
belonging to the same cluster pack do closely that they look like black scribbly dots.
There are a total of 19 clusters. Given the proximity of scooters of the same cluster, 
perhaps the mega charging bus can more efficiently charge scooters by charging 
scooters from the same cluster at a time. The bus could travel from its parking 
location to the nearest cluster and work its way through each cluster, charging 
scooters from one cluster before moving on to scooters in the next cluster.

Keeping these thoughts in mind, I investigated the distribution of scooter power levels 
to see if there was anything about it that could inspire more ideas about an efficient 
scooter-charging strategy. At this time I also created another column in the 
Scooter data frame for the number of hours it would take for each scooter to charge 
to full battery.
```{r}
Scooters$charge_time <- as.integer(5 - Scooters$power_level)
str(Scooters)
summary(Scooters)

freq <- vector(length = 6)
for (i in 0:5)
{
  freq[i + 1] <- nrow(Scooters[Scooters$power_level == i, ])
}
barplot(freq, names.arg = c("0", "1", "2", "3", "4", "5"), xlab = "Power Level", ylab = "Scooter Count", ylim = c(0, 5000))
```

The bar graph shows an even distribution of power levels, suggesting that the mega 
charging bus might have an equal chance of encountering a scooter at any power level. 
Finding a way to pinpoint scooters especially at low power levels would improve 
efficiency and service, though I don't think I will have the time to implement this.

However, I can find the distance of each scooter to the mega charging bus's parked 
location to find the scooter closest to it. Perhaps the cluster that scooter belongs 
to will be the first group of scooters to get charged to full battery. 
```{r}
dist <- function(x1, y1, x2, y2)
{
  sqrt((x1 - x2)^2 + (y1 - y2)^2)
}
Scooters$dist_from_bus <- as.numeric(dist(Scooters$xcoordinate, Scooters$ycoordinate, 20.19, 20.19))
str(Scooters)
summary(Scooters)
# looks like scooter 3027 is closest to the bus's parking location
Scooters[which.min(Scooters$dist_from_bus), ] 
plot(x = Scooters[c(1:3027, 3029:25668), 2], y = Scooters[c(1:3027, 3029:25668), 3], type = "p", 
     axes = FALSE, main = "Scooter Locations", xlab = "X Coordinate", ylab = "Y Coordinate")
axis(1, at = seq(-0.3, 1.4, 0.1), labels = label)
axis(2, at = seq(-0.3, 1.4, 0.1), labels = label)
points(x = Scooters[3028, 2], y = Scooters[3028, 3], pch = 17, col = "red")
```

Here's the same graph as shown earlier, but now the red triangle indicates the scooter closest to the parking location of the charging bus.

To determine the time needed for the bus to travel to all clusters, I used a R's
built-in k-means algorithm to calculate the mean x and y coordinate of each cluster. 
It helps to already have relatively well-defined clusters in the data and know 
the number of clusters when using this algorithm, and since the scooter data on 
the x and y coordinates fits these critera, I decided to give it a try and come 
up with another strategy if it fails. (Spoilers: Looking at the graph of the raw 
data of x and y coordinates, it didn't fail.) As reference, 
the red triangle indicates the scooter closest to the parking location of the 
charging bus. If the bus charged scooters from that cluster first, it would start 
at cluster 14.
```{r}
set.seed(15)
area <- kmeans(Scooters[, 2:3], 19, nstart = 40, algorithm = "Hartigan-Wong")
plot(area$centers, main = "Mean Coordinates for all Clusters", xlab = "X Coordinate", ylab = "Y Coordinate")
points(x = Scooters[3028, 2], y = Scooters[3028, 3], pch = 17, col = "red")
text(area$centers, pos = 4)
```

At this point I wondered if power levels were in any way associated with which 
cluster scooters were in, so I printed a matrix of power levels for all clusters.
```{r}
# a matrix of the distribution of scooter power levels for each cluster
# row number corresponds to hub number and (column number - 1) corresponds to power level
Power_among_hubs <- matrix(nrow = 19, ncol = 6) 
for (j in 0:5)
{
  for (i in 1:19)
  {
    Power_among_hubs[i, j + 1] <- nrow(Scooters[Scooters$power_level == j, Scooters$hub == i])
  }
}
Power_among_hubs
```

Given that each cluster had scooters of different power levels within two orders 
of magnitude and that clusters had the same distribution, there is no 
mathematical need for the bus to prioritize one cluster over another.

Having the mega charging bus travel to all clusters in the minimum amount of time 
to maximize efficieny means the bus should travel a minimum distance, since 
$distance = speed * time$. Interpreting the mean coordinates of each cluster as 
a vertex in a graph would make it a traveling salesman problem, assuming for the 
moment that the roads the bus travels on follows the edges between vertices. One 
process for finding an optimum solution involves construct a minimum spanning 
tree (MST) out of the vertices, running a preorder traversal on the MST starting 
from the vertex corresponding to the cluster containing the scooter closest to 
the parked bus, and reporting the order of the vertices visited. 
Methods in the TSP library exist that do this process, so I didn't have to 
implement it from scratch.
```{r}
library(TSP)
etsp <- ETSP(area$centers) # the Euclidean traveling salesman problem
method <- c("nearest_insertion", "cheapest_insertion", "farthest_insertion", 
            "arbitrary_insertion", "nn", "repetitive_nn")
(tours <- lapply(method, FUN = function(m) solve_TSP(etsp, method = m, start = 14)))
```

The library offers many different approaches for constructing an MST, so I decided 
to try a handful of them and pick the one that finds the shortest tour. From 
inspecting the tour lengths, the fourth tour has the shortest tour. Assuming the 
distance is in miles, this would mean the bus would have to travel 5.530296 miles to reach 
all clusters if it started at cluster 14, the cluster closest to the parked bus.

```{r}
optimal_soln <- tours[[3]] 
attr(optimal_soln, "tour_length")
```

The bus's itnerary would follow the order of the clusters listed below:
```{r}
attr(optimal_soln, "name") # cluster 18 is the last cluster
```

An estimate of the total distance the bus would travel starting from its parking 
location and through the tour starting and ending at cluster 14 is 32.32176 miles, 
and this would take about 39 minutes traveling at 50 miles per hour ignoring 
the time it takes to accelerate to that speed from rest.
```{r}
(shortest_path_dist <- attr(optimal_soln, "tour_length") 
                            + dist(area$centers[14, 1], area$centers[14, 2], 20.19, 20.19))
((shortest_path_dist / 50) * 60)
```

If the bus stopped at each cluster to charge scooters, all of which have scooters 
at 0 power level, and didn't depart to the next cluster until all scooters were fully 
charged, it would take the bus about 96 hours, or a little less than 4 days to reach 
all clusters, which isn't really efficient, prioritizes scooters at one particular 
location over others, and ignores the fact that the bus cannot park at each cluster.

```{r}
# find max of time to charge within each cluster and add this to total time
(shortest_path_time <- shortest_path_dist / 50 + 19 * 5)
```

If the bus traveled while charging scooters (assuming this is possible) and dropped 
off fully charged scooters at the next cluster the bus arrives at (assuming drop off 
locations are arbitrary), the bus would make the tour (on the order of minutes) 
several times before scooters were fully charged (on the order of several hours). 
This might work, but if the bus has a limit on how many scooters it can charge 
at any point in time, then the bus might end up prioritizing charging scooters in
the clusters it reaches first. 

Therefore, it might be worth considering the bus 
picking up a select number of scooters at low power level from each cluster (this 
number can vary depending on the demand and other factors) without stopping for 
a scooter to be fully charged before moving to the next cluster on the itinerary. 
Once the bus has traveled to all clusters on a tour, it would drive to its parking 
location. When the scooters reach full battery level, the bus would leave its 
parking location to make the tour again, dropping scooters off at each cluster 
where scooters are popular and possibly reloading more scooters needing to 
be charged at each cluster and repeating until all scooters have been fully charged.
When considering the time it takes to fully charge all scooters with this strategy, 
suppose the bus has a capacity, $c$. The total number of tours the bus would 
have to make, $i$, would be $i = \frac{n}{c} + 1$ where $n$ is the total number 
of scooters not at full power level. The plus one comes from the last tour where the bus drops off the last set of scooters needed to be fully charged. 
```{r}
(n <- nrow(Scooters[Scooters$power_level != 5, ])) # number of scooters not at power level 5
```
The distance in miles of the round trip of starting and ending at the bus's parking location, $d$, is $d = i(2 * \text{distance from parking location to mean coordinate of the
nearest cluster} + \text{length of 1 tour})$.
```{r}
(distances <- 2 * dist(area$centers[14, 1], area$centers[14, 2], 20.19, 20.19) + 5.530296)
```

Considering the worst case scenario where the bus always picks up a scooter at power level 
0 each time it picks up scooters, the bus would have to wait a time, $t_{\text{wait}} 
= 5 * \frac{n}{c}$ in hours. 
The time in hours it would take for all scooters to be fully charged depends on 
how long it takes until the last scooter is fully charged. This is equivalent to 
$\frac{d}{50} + t_{\text{wait}}$, or 
```{r}
(distances / 50)
(5 * 21325)

```

$1.182264(\frac{21325}{c} + 1) + \frac{106625}{c}$.
In order for all scooters to be charged within a day (24 hours), 
$1.182264(\frac{21325}{c} + 1) + \frac{106625}{c} < 24$, so $c > 5777.82$. In 
other words, the bus must have a capacity of at least 5778 scooters using this 
strategy to charge all scooters within a day.
